{"ast":null,"code":"import { Editor, Transforms, Node } from 'slate';\n\n/**\n * @description Creates or updates an existing $elementType. It also takes care\n * of the saved selection and uses PathRef.\n *\n * @param {Editor} editor The Slate editor for the context\n * @param {object} data Relevant data for this element\n *\n * @returns {boolean} true if an element was possibly inserted, false otherwise\n * (currently we do not check here if the element was already applied to the\n * editor)\n */\nexport const _insertElement = elementType => (editor, data) => {\n  if (editor.getSavedSelection()) {\n    const selection = editor.selection || editor.getSavedSelection();\n    const rangeRef = Editor.rangeRef(editor, selection);\n    const res = Array.from(Editor.nodes(editor, {\n      match: n => n.type === elementType,\n      mode: 'highest',\n      at: selection\n    }));\n    if (res.length) {\n      const [, path] = res[0];\n      Transforms.setNodes(editor, {\n        data\n      }, {\n        at: path ? path : null,\n        match: path ? n => n.type === elementType : null\n      });\n    } else {\n      Transforms.wrapNodes(editor, {\n        type: elementType,\n        data\n      }, {\n        split: true,\n        at: selection,\n        match: node => {\n          return Node.string(node).length !== 0;\n        }\n      } //,\n      );\n    }\n\n    const sel = JSON.parse(JSON.stringify(rangeRef.current));\n    Transforms.select(editor, sel);\n    editor.setSavedSelection(sel);\n    return true;\n  }\n  return false;\n};\n\n/**\n * Will unwrap a node that has as type the one received or one from an array.\n * It identifies the current target element and expands the selection to it, in\n * case the selection was just partial. This allows a \"clear and reassign\"\n * operation, for example for the Link plugin.\n *\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - current node\n */\nexport const _unwrapElement = elementType => editor => {\n  const [link] = Editor.nodes(editor, {\n    at: editor.selection,\n    match: node => (node === null || node === void 0 ? void 0 : node.type) === elementType\n  });\n  const [, path] = link;\n  const [start, end] = Editor.edges(editor, path);\n  const range = {\n    anchor: start,\n    focus: end\n  };\n  const ref = Editor.rangeRef(editor, range);\n  Transforms.select(editor, range);\n  Transforms.unwrapNodes(editor, {\n    match: n => Array.isArray(elementType) ? elementType.includes(n.type) : n.type === elementType,\n    at: range\n  });\n  const current = ref.current;\n  ref.unref();\n  return current;\n};\nexport const _isActiveElement = elementType => editor => {\n  const selection = editor.selection || editor.getSavedSelection();\n  let found;\n  try {\n    found = Array.from(Editor.nodes(editor, {\n      match: n => n.type === elementType,\n      at: selection\n    }) || []);\n  } catch (e) {\n    // eslint-disable-next-line\n    // console.warn('Error in finding active element', e);\n    return false;\n  }\n  if (found.length) return true;\n  if (selection) {\n    const {\n      path\n    } = selection.anchor;\n    const isAtStart = selection.anchor.offset === 0 && selection.focus.offset === 0;\n    if (isAtStart) {\n      try {\n        found = Editor.previous(editor, {\n          at: path\n          // match: (n) => n.type === MENTION,\n        });\n      } catch (ex) {\n        found = [];\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Will look for a node that has as type the one received or one from an array\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - found node\n */\nexport const _getActiveElement = elementType => function (editor) {\n  let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'any';\n  const selection = editor.selection || editor.getSavedSelection();\n  let found = [];\n  try {\n    found = Array.from(Editor.nodes(editor, {\n      match: n => Array.isArray(elementType) ? elementType.includes(n.type) : n.type === elementType,\n      at: selection\n    }));\n  } catch (e) {\n    return null;\n  }\n  if (found.length) return found[0];\n  if (!selection) return null;\n  if (direction === 'any' || direction === 'backward') {\n    const {\n      path\n    } = selection.anchor;\n    const isAtStart = selection.anchor.offset === 0 && selection.focus.offset === 0;\n    if (isAtStart) {\n      let found;\n      try {\n        found = Editor.previous(editor, {\n          at: path\n        });\n      } catch (ex) {\n        // eslint-disable-next-line no-console\n        console.warn('Unable to find previous node', editor, path);\n        return;\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        if (Array.isArray(elementType) && elementType.includes(found[0].type) || found[0].type === elementType) {\n          return found;\n        }\n      } else {\n        return null;\n      }\n    }\n  }\n  if (direction === 'any' || direction === 'forward') {\n    const {\n      path\n    } = selection.anchor;\n    const isAtStart = selection.anchor.offset === 0 && selection.focus.offset === 0;\n    if (isAtStart) {\n      let found;\n      try {\n        found = Editor.next(editor, {\n          at: path\n        });\n      } catch (e) {\n        // eslint-disable-next-line\n        console.warn('Unable to find next node', editor, path);\n        return;\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        if (Array.isArray(elementType) && elementType.includes(found[0].type) || found[0].type === elementType) {\n          return found;\n        }\n      } else {\n        return null;\n      }\n    }\n  }\n  return null;\n};","map":{"version":3,"names":["Editor","Transforms","Node","_insertElement","elementType","editor","data","getSavedSelection","selection","rangeRef","res","Array","from","nodes","match","n","type","mode","at","length","path","setNodes","wrapNodes","split","node","string","sel","JSON","parse","stringify","current","select","setSavedSelection","_unwrapElement","link","start","end","edges","range","anchor","focus","ref","unwrapNodes","isArray","includes","unref","_isActiveElement","found","e","isAtStart","offset","previous","ex","_getActiveElement","direction","console","warn","next"],"sources":["/Users/cihanandac/Documents/code-files/utrechtsciencepark/utrecht-science-park/frontend/node_modules/@plone/volto/packages/volto-slate/src/elementEditor/utils.js"],"sourcesContent":["import { Editor, Transforms, Node } from 'slate';\n\n/**\n * @description Creates or updates an existing $elementType. It also takes care\n * of the saved selection and uses PathRef.\n *\n * @param {Editor} editor The Slate editor for the context\n * @param {object} data Relevant data for this element\n *\n * @returns {boolean} true if an element was possibly inserted, false otherwise\n * (currently we do not check here if the element was already applied to the\n * editor)\n */\nexport const _insertElement = (elementType) => (editor, data) => {\n  if (editor.getSavedSelection()) {\n    const selection = editor.selection || editor.getSavedSelection();\n\n    const rangeRef = Editor.rangeRef(editor, selection);\n\n    const res = Array.from(\n      Editor.nodes(editor, {\n        match: (n) => n.type === elementType,\n        mode: 'highest',\n        at: selection,\n      }),\n    );\n\n    if (res.length) {\n      const [, path] = res[0];\n      Transforms.setNodes(\n        editor,\n        { data },\n        {\n          at: path ? path : null,\n          match: path ? (n) => n.type === elementType : null,\n        },\n      );\n    } else {\n      Transforms.wrapNodes(\n        editor,\n        { type: elementType, data },\n        {\n          split: true,\n          at: selection,\n          match: (node) => {\n            return Node.string(node).length !== 0;\n          },\n        }, //,\n      );\n    }\n\n    const sel = JSON.parse(JSON.stringify(rangeRef.current));\n    Transforms.select(editor, sel);\n    editor.setSavedSelection(sel);\n\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Will unwrap a node that has as type the one received or one from an array.\n * It identifies the current target element and expands the selection to it, in\n * case the selection was just partial. This allows a \"clear and reassign\"\n * operation, for example for the Link plugin.\n *\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - current node\n */\nexport const _unwrapElement = (elementType) => (editor) => {\n  const [link] = Editor.nodes(editor, {\n    at: editor.selection,\n    match: (node) => node?.type === elementType,\n  });\n  const [, path] = link;\n  const [start, end] = Editor.edges(editor, path);\n  const range = { anchor: start, focus: end };\n\n  const ref = Editor.rangeRef(editor, range);\n\n  Transforms.select(editor, range);\n  Transforms.unwrapNodes(editor, {\n    match: (n) =>\n      Array.isArray(elementType)\n        ? elementType.includes(n.type)\n        : n.type === elementType,\n    at: range,\n  });\n\n  const current = ref.current;\n  ref.unref();\n\n  return current;\n};\n\nexport const _isActiveElement = (elementType) => (editor) => {\n  const selection = editor.selection || editor.getSavedSelection();\n  let found;\n  try {\n    found = Array.from(\n      Editor.nodes(editor, {\n        match: (n) => n.type === elementType,\n        at: selection,\n      }) || [],\n    );\n  } catch (e) {\n    // eslint-disable-next-line\n    // console.warn('Error in finding active element', e);\n    return false;\n  }\n  if (found.length) return true;\n\n  if (selection) {\n    const { path } = selection.anchor;\n    const isAtStart =\n      selection.anchor.offset === 0 && selection.focus.offset === 0;\n\n    if (isAtStart) {\n      try {\n        found = Editor.previous(editor, {\n          at: path,\n          // match: (n) => n.type === MENTION,\n        });\n      } catch (ex) {\n        found = [];\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n/**\n * Will look for a node that has as type the one received or one from an array\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - found node\n */\nexport const _getActiveElement = (elementType) => (\n  editor,\n  direction = 'any',\n) => {\n  const selection = editor.selection || editor.getSavedSelection();\n  let found = [];\n\n  try {\n    found = Array.from(\n      Editor.nodes(editor, {\n        match: (n) =>\n          Array.isArray(elementType)\n            ? elementType.includes(n.type)\n            : n.type === elementType,\n        at: selection,\n      }),\n    );\n  } catch (e) {\n    return null;\n  }\n\n  if (found.length) return found[0];\n\n  if (!selection) return null;\n\n  if (direction === 'any' || direction === 'backward') {\n    const { path } = selection.anchor;\n    const isAtStart =\n      selection.anchor.offset === 0 && selection.focus.offset === 0;\n\n    if (isAtStart) {\n      let found;\n      try {\n        found = Editor.previous(editor, {\n          at: path,\n        });\n      } catch (ex) {\n        // eslint-disable-next-line no-console\n        console.warn('Unable to find previous node', editor, path);\n        return;\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        if (\n          (Array.isArray(elementType) && elementType.includes(found[0].type)) ||\n          found[0].type === elementType\n        ) {\n          return found;\n        }\n      } else {\n        return null;\n      }\n    }\n  }\n\n  if (direction === 'any' || direction === 'forward') {\n    const { path } = selection.anchor;\n    const isAtStart =\n      selection.anchor.offset === 0 && selection.focus.offset === 0;\n\n    if (isAtStart) {\n      let found;\n      try {\n        found = Editor.next(editor, {\n          at: path,\n        });\n      } catch (e) {\n        // eslint-disable-next-line\n        console.warn('Unable to find next node', editor, path);\n        return;\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        if (\n          (Array.isArray(elementType) && elementType.includes(found[0].type)) ||\n          found[0].type === elementType\n        ) {\n          return found;\n        }\n      } else {\n        return null;\n      }\n    }\n  }\n\n  return null;\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}