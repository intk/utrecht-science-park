{"ast":null,"code":"import _objectSpread from \"/Users/cihanandac/Documents/code-files/utrechtsciencepark/utrecht-science-park/frontend/node_modules/babel-preset-razzle/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { isCmsUi } from '@plone/volto/helpers';\nconst LOCATION_CHANGE = '@@router/LOCATION_CHANGE';\nconst PROTECT_START = '@@loadProtector/START';\nconst PROTECT_END = '@@loadProtector/END';\nconst PROTECT_SKIPPED = '@@loadProtector/SKIPPED';\nconst GET_CONTENT_PENDING = 'GET_CONTENT_PENDING';\nconst GET_CONTENT_SUCCESS = 'GET_CONTENT_SUCCESS';\nconst GET_CONTENT_FAIL = 'GET_CONTENT_FAIL';\nconst RESET_CONTENT = 'RESET_CONTENT';\n\n// ---\n// The load protector middlewares have multiple purposes.\n//\n// 1. Maintained a delayed location that can be used to trigger an UI\n// change (such as scroll to top) after all content for the page has been\n// loaded.\n//\n// 2. When moving from a non content route to a content route, issue\n// a data reset before the content load operation. - However do not do\n// such a reset when navigating between two content routes.\n// ---\n\nexport const protectLoadStart = _ref => {\n  let {\n    dispatch,\n    getState\n  } = _ref;\n  return next => action => {\n    if (typeof action === 'function') {\n      return next(action);\n    }\n    switch (action.type) {\n      case LOCATION_CHANGE:\n        const {\n          location\n        } = action.payload;\n        const {\n          pathname: path\n        } = location;\n        const currentPath = getState().router.location.pathname;\n        const result = next(action);\n        if (isCmsUi(path)) {\n          // Next path: isCmsUI, Non Content. There is no\n          // loading here, so skip counting altogether.\n          // Will update the delayed location constantly.\n          dispatch({\n            type: PROTECT_SKIPPED,\n            location\n          });\n        } else {\n          dispatch({\n            type: PROTECT_START,\n            location,\n            // Only reset before the fetch, if we depart from\n            // a not isCmsUi, Content pass. However, reset will\n            // not occur if moving between two content paths,\n            // only the postponed location will be booked.\n            resetBeforeFetch: isCmsUi(currentPath)\n          });\n        }\n        return result;\n      default:\n        return next(action);\n    }\n  };\n};\n\n// Note that there is a bit of heuristics here. We assume that every action\n// like this is beginning/ending an action. If this logic fails then the counting\n// will be off, resulting either a premature or an indefinitely missing state change.\nconst isRequestAction = action => action.type.endsWith('_PENDING');\nconst isResponseAction = action => action.type.endsWith('_SUCCESS') || action.type.endsWith('_FAIL');\n\n// Action map defines an action to be emitted before the key action\nconst mapActions = {\n  [GET_CONTENT_PENDING]: RESET_CONTENT\n};\nexport const protectLoadEnd = _ref2 => {\n  let {\n    dispatch,\n    getState\n  } = _ref2;\n  return next => action => {\n    if (typeof action === 'function') {\n      return next(action);\n    }\n    const {\n      isCounting,\n      resetBeforeFetch,\n      requestCount\n    } = getState().loadProtector;\n    if (resetBeforeFetch) {\n      const type = mapActions[action.type];\n      if (type) {\n        dispatch({\n          type\n        });\n      }\n    }\n    if (isCounting && requestCount === 1 && isResponseAction(action)) {\n      setTimeout(() => dispatch({\n        type: PROTECT_END\n      }), 0);\n    }\n    return next(action);\n  };\n};\nexport function loadProtector() {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  switch (action.type) {\n    case PROTECT_START:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        requestCount: 0,\n        isCounting: true,\n        resetBeforeFetch: action.resetBeforeFetch,\n        postponedLocation: action.location\n      });\n    case PROTECT_END:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false\n      });\n    case PROTECT_SKIPPED:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false,\n        postponedLocation: null,\n        location: action.location\n      });\n    case GET_CONTENT_SUCCESS:\n    case GET_CONTENT_FAIL:\n      if (state.isCounting) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          requestCount: state.requestCount - 1,\n          postponedLocation: null,\n          location: state.postponedLocation\n        });\n      } else {\n        return state;\n      }\n    case RESET_CONTENT:\n      if (state.resetBeforeFetch) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          resetBeforeFetch: false\n        });\n      } else {\n        return state;\n      }\n    default:\n      const {\n        isCounting,\n        requestCount\n      } = state;\n      if (isCounting && isRequestAction(action)) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          requestCount: requestCount + 1\n        });\n      } else if (isCounting && isResponseAction(action)) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          requestCount: requestCount - 1\n        });\n      } else {\n        return state;\n      }\n  }\n}","map":{"version":3,"names":["isCmsUi","LOCATION_CHANGE","PROTECT_START","PROTECT_END","PROTECT_SKIPPED","GET_CONTENT_PENDING","GET_CONTENT_SUCCESS","GET_CONTENT_FAIL","RESET_CONTENT","protectLoadStart","dispatch","getState","next","action","type","location","payload","pathname","path","currentPath","router","result","resetBeforeFetch","isRequestAction","endsWith","isResponseAction","mapActions","protectLoadEnd","isCounting","requestCount","loadProtector","setTimeout","state","postponedLocation"],"sources":["/Users/cihanandac/Documents/code-files/utrechtsciencepark/utrecht-science-park/frontend/node_modules/@plone/volto/src/middleware/storeProtectLoadUtils.js"],"sourcesContent":["import { isCmsUi } from '@plone/volto/helpers';\n\nconst LOCATION_CHANGE = '@@router/LOCATION_CHANGE';\nconst PROTECT_START = '@@loadProtector/START';\nconst PROTECT_END = '@@loadProtector/END';\nconst PROTECT_SKIPPED = '@@loadProtector/SKIPPED';\nconst GET_CONTENT_PENDING = 'GET_CONTENT_PENDING';\nconst GET_CONTENT_SUCCESS = 'GET_CONTENT_SUCCESS';\nconst GET_CONTENT_FAIL = 'GET_CONTENT_FAIL';\nconst RESET_CONTENT = 'RESET_CONTENT';\n\n// ---\n// The load protector middlewares have multiple purposes.\n//\n// 1. Maintained a delayed location that can be used to trigger an UI\n// change (such as scroll to top) after all content for the page has been\n// loaded.\n//\n// 2. When moving from a non content route to a content route, issue\n// a data reset before the content load operation. - However do not do\n// such a reset when navigating between two content routes.\n// ---\n\nexport const protectLoadStart = ({ dispatch, getState }) => (next) => (\n  action,\n) => {\n  if (typeof action === 'function') {\n    return next(action);\n  }\n  switch (action.type) {\n    case LOCATION_CHANGE:\n      const { location } = action.payload;\n      const { pathname: path } = location;\n      const currentPath = getState().router.location.pathname;\n      const result = next(action);\n      if (isCmsUi(path)) {\n        // Next path: isCmsUI, Non Content. There is no\n        // loading here, so skip counting altogether.\n        // Will update the delayed location constantly.\n        dispatch({\n          type: PROTECT_SKIPPED,\n          location,\n        });\n      } else {\n        dispatch({\n          type: PROTECT_START,\n          location,\n          // Only reset before the fetch, if we depart from\n          // a not isCmsUi, Content pass. However, reset will\n          // not occur if moving between two content paths,\n          // only the postponed location will be booked.\n          resetBeforeFetch: isCmsUi(currentPath),\n        });\n      }\n      return result;\n    default:\n      return next(action);\n  }\n};\n\n// Note that there is a bit of heuristics here. We assume that every action\n// like this is beginning/ending an action. If this logic fails then the counting\n// will be off, resulting either a premature or an indefinitely missing state change.\nconst isRequestAction = (action) => action.type.endsWith('_PENDING');\nconst isResponseAction = (action) =>\n  action.type.endsWith('_SUCCESS') || action.type.endsWith('_FAIL');\n\n// Action map defines an action to be emitted before the key action\nconst mapActions = {\n  [GET_CONTENT_PENDING]: RESET_CONTENT,\n};\n\nexport const protectLoadEnd = ({ dispatch, getState }) => (next) => (\n  action,\n) => {\n  if (typeof action === 'function') {\n    return next(action);\n  }\n  const {\n    isCounting,\n    resetBeforeFetch,\n    requestCount,\n  } = getState().loadProtector;\n  if (resetBeforeFetch) {\n    const type = mapActions[action.type];\n    if (type) {\n      dispatch({ type });\n    }\n  }\n  if (isCounting && requestCount === 1 && isResponseAction(action)) {\n    setTimeout(\n      () =>\n        dispatch({\n          type: PROTECT_END,\n        }),\n      0,\n    );\n  }\n  return next(action);\n};\n\nexport function loadProtector(state = {}, action = {}) {\n  switch (action.type) {\n    case PROTECT_START:\n      return {\n        ...state,\n        requestCount: 0,\n        isCounting: true,\n        resetBeforeFetch: action.resetBeforeFetch,\n        postponedLocation: action.location,\n      };\n    case PROTECT_END:\n      return {\n        ...state,\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false,\n      };\n    case PROTECT_SKIPPED:\n      return {\n        ...state,\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false,\n        postponedLocation: null,\n        location: action.location,\n      };\n    case GET_CONTENT_SUCCESS:\n    case GET_CONTENT_FAIL:\n      if (state.isCounting) {\n        return {\n          ...state,\n          requestCount: state.requestCount - 1,\n          postponedLocation: null,\n          location: state.postponedLocation,\n        };\n      } else {\n        return state;\n      }\n    case RESET_CONTENT:\n      if (state.resetBeforeFetch) {\n        return {\n          ...state,\n          resetBeforeFetch: false,\n        };\n      } else {\n        return state;\n      }\n    default:\n      const { isCounting, requestCount } = state;\n      if (isCounting && isRequestAction(action)) {\n        return {\n          ...state,\n          requestCount: requestCount + 1,\n        };\n      } else if (isCounting && isResponseAction(action)) {\n        return {\n          ...state,\n          requestCount: requestCount - 1,\n        };\n      } else {\n        return state;\n      }\n  }\n}\n"],"mappings":";AAAA,SAASA,OAAO,QAAQ,sBAAsB;AAE9C,MAAMC,eAAe,GAAG,0BAA0B;AAClD,MAAMC,aAAa,GAAG,uBAAuB;AAC7C,MAAMC,WAAW,GAAG,qBAAqB;AACzC,MAAMC,eAAe,GAAG,yBAAyB;AACjD,MAAMC,mBAAmB,GAAG,qBAAqB;AACjD,MAAMC,mBAAmB,GAAG,qBAAqB;AACjD,MAAMC,gBAAgB,GAAG,kBAAkB;AAC3C,MAAMC,aAAa,GAAG,eAAe;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,gBAAgB,GAAG;EAAA,IAAC;IAAEC,QAAQ;IAAEC;EAAS,CAAC;EAAA,OAAMC,IAAI,IAC/DC,MAAM,IACH;IACH,IAAI,OAAOA,MAAM,KAAK,UAAU,EAAE;MAChC,OAAOD,IAAI,CAACC,MAAM,CAAC;IACrB;IACA,QAAQA,MAAM,CAACC,IAAI;MACjB,KAAKb,eAAe;QAClB,MAAM;UAAEc;QAAS,CAAC,GAAGF,MAAM,CAACG,OAAO;QACnC,MAAM;UAAEC,QAAQ,EAAEC;QAAK,CAAC,GAAGH,QAAQ;QACnC,MAAMI,WAAW,GAAGR,QAAQ,EAAE,CAACS,MAAM,CAACL,QAAQ,CAACE,QAAQ;QACvD,MAAMI,MAAM,GAAGT,IAAI,CAACC,MAAM,CAAC;QAC3B,IAAIb,OAAO,CAACkB,IAAI,CAAC,EAAE;UACjB;UACA;UACA;UACAR,QAAQ,CAAC;YACPI,IAAI,EAAEV,eAAe;YACrBW;UACF,CAAC,CAAC;QACJ,CAAC,MAAM;UACLL,QAAQ,CAAC;YACPI,IAAI,EAAEZ,aAAa;YACnBa,QAAQ;YACR;YACA;YACA;YACA;YACAO,gBAAgB,EAAEtB,OAAO,CAACmB,WAAW;UACvC,CAAC,CAAC;QACJ;QACA,OAAOE,MAAM;MACf;QACE,OAAOT,IAAI,CAACC,MAAM,CAAC;IAAC;EAE1B,CAAC;AAAA;;AAED;AACA;AACA;AACA,MAAMU,eAAe,GAAIV,MAAM,IAAKA,MAAM,CAACC,IAAI,CAACU,QAAQ,CAAC,UAAU,CAAC;AACpE,MAAMC,gBAAgB,GAAIZ,MAAM,IAC9BA,MAAM,CAACC,IAAI,CAACU,QAAQ,CAAC,UAAU,CAAC,IAAIX,MAAM,CAACC,IAAI,CAACU,QAAQ,CAAC,OAAO,CAAC;;AAEnE;AACA,MAAME,UAAU,GAAG;EACjB,CAACrB,mBAAmB,GAAGG;AACzB,CAAC;AAED,OAAO,MAAMmB,cAAc,GAAG;EAAA,IAAC;IAAEjB,QAAQ;IAAEC;EAAS,CAAC;EAAA,OAAMC,IAAI,IAC7DC,MAAM,IACH;IACH,IAAI,OAAOA,MAAM,KAAK,UAAU,EAAE;MAChC,OAAOD,IAAI,CAACC,MAAM,CAAC;IACrB;IACA,MAAM;MACJe,UAAU;MACVN,gBAAgB;MAChBO;IACF,CAAC,GAAGlB,QAAQ,EAAE,CAACmB,aAAa;IAC5B,IAAIR,gBAAgB,EAAE;MACpB,MAAMR,IAAI,GAAGY,UAAU,CAACb,MAAM,CAACC,IAAI,CAAC;MACpC,IAAIA,IAAI,EAAE;QACRJ,QAAQ,CAAC;UAAEI;QAAK,CAAC,CAAC;MACpB;IACF;IACA,IAAIc,UAAU,IAAIC,YAAY,KAAK,CAAC,IAAIJ,gBAAgB,CAACZ,MAAM,CAAC,EAAE;MAChEkB,UAAU,CACR,MACErB,QAAQ,CAAC;QACPI,IAAI,EAAEX;MACR,CAAC,CAAC,EACJ,CAAC,CACF;IACH;IACA,OAAOS,IAAI,CAACC,MAAM,CAAC;EACrB,CAAC;AAAA;AAED,OAAO,SAASiB,aAAa,GAA0B;EAAA,IAAzBE,KAAK,uEAAG,CAAC,CAAC;EAAA,IAAEnB,MAAM,uEAAG,CAAC,CAAC;EACnD,QAAQA,MAAM,CAACC,IAAI;IACjB,KAAKZ,aAAa;MAChB,uCACK8B,KAAK;QACRH,YAAY,EAAE,CAAC;QACfD,UAAU,EAAE,IAAI;QAChBN,gBAAgB,EAAET,MAAM,CAACS,gBAAgB;QACzCW,iBAAiB,EAAEpB,MAAM,CAACE;MAAQ;IAEtC,KAAKZ,WAAW;MACd,uCACK6B,KAAK;QACRH,YAAY,EAAE,CAAC;QACfD,UAAU,EAAE,KAAK;QACjBN,gBAAgB,EAAE;MAAK;IAE3B,KAAKlB,eAAe;MAClB,uCACK4B,KAAK;QACRH,YAAY,EAAE,CAAC;QACfD,UAAU,EAAE,KAAK;QACjBN,gBAAgB,EAAE,KAAK;QACvBW,iBAAiB,EAAE,IAAI;QACvBlB,QAAQ,EAAEF,MAAM,CAACE;MAAQ;IAE7B,KAAKT,mBAAmB;IACxB,KAAKC,gBAAgB;MACnB,IAAIyB,KAAK,CAACJ,UAAU,EAAE;QACpB,uCACKI,KAAK;UACRH,YAAY,EAAEG,KAAK,CAACH,YAAY,GAAG,CAAC;UACpCI,iBAAiB,EAAE,IAAI;UACvBlB,QAAQ,EAAEiB,KAAK,CAACC;QAAiB;MAErC,CAAC,MAAM;QACL,OAAOD,KAAK;MACd;IACF,KAAKxB,aAAa;MAChB,IAAIwB,KAAK,CAACV,gBAAgB,EAAE;QAC1B,uCACKU,KAAK;UACRV,gBAAgB,EAAE;QAAK;MAE3B,CAAC,MAAM;QACL,OAAOU,KAAK;MACd;IACF;MACE,MAAM;QAAEJ,UAAU;QAAEC;MAAa,CAAC,GAAGG,KAAK;MAC1C,IAAIJ,UAAU,IAAIL,eAAe,CAACV,MAAM,CAAC,EAAE;QACzC,uCACKmB,KAAK;UACRH,YAAY,EAAEA,YAAY,GAAG;QAAC;MAElC,CAAC,MAAM,IAAID,UAAU,IAAIH,gBAAgB,CAACZ,MAAM,CAAC,EAAE;QACjD,uCACKmB,KAAK;UACRH,YAAY,EAAEA,YAAY,GAAG;QAAC;MAElC,CAAC,MAAM;QACL,OAAOG,KAAK;MACd;EAAC;AAEP"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}