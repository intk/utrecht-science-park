{"ast":null,"code":"import _merge from \"lodash/merge\";\nimport _keys from \"lodash/keys\";\nimport _isObject from \"lodash/isObject\";\nimport _find from \"lodash/find\";\nimport _endsWith from \"lodash/endsWith\";\nimport _without from \"lodash/without\";\nimport _omit from \"lodash/omit\";\nconst _excluded = [\"data\", \"intl\"];\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport move from 'lodash-move';\nimport { v4 as uuid } from 'uuid';\nimport config from '@plone/volto/registry';\nimport { applySchemaEnhancer } from '@plone/volto/helpers';\n\n/**\n * Get blocks field.\n * @function getBlocksFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the blocks\n */\nexport function getBlocksFieldname(props) {\n  return _find(_keys(props), key => key !== 'volto.blocks' && _endsWith(key, 'blocks')) || null;\n}\n\n/**\n * Get blocks layout field.\n * @function getBlocksLayoutFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the blocks layout\n */\nexport function getBlocksLayoutFieldname(props) {\n  return _find(_keys(props), key => key !== 'volto.blocks' && _endsWith(key, 'blocks_layout')) || null;\n}\n\n/**\n * Has blocks data.\n * @function hasBlocksData\n * @param {Object} props Properties.\n * @return {boolean} True if it has blocks data.\n */\nexport function hasBlocksData(props) {\n  return _find(_keys(props), key => key !== 'volto.blocks' && _endsWith(key, 'blocks')) !== undefined;\n}\n\n/**\n * Pluggable method to test if a block has a set value (any non-empty value)\n * @function blockHasValue\n * @param {Object} data Block data\n * @return {boolean} True if block has a non-empty value\n */\nexport function blockHasValue(data) {\n  var _blocks$blocksConfig$;\n  const {\n    blocks\n  } = config;\n  const blockType = data['@type'];\n  const check = (_blocks$blocksConfig$ = blocks.blocksConfig[blockType]) === null || _blocks$blocksConfig$ === void 0 ? void 0 : _blocks$blocksConfig$.blockHasValue;\n  if (!check) {\n    return true;\n  }\n  return check(data);\n}\n\n/**\n * Get block pairs of [id, block] from content properties\n * @function getBlocks\n * @param {Object} properties\n * @return {Array} a list of block [id, value] pairs, in order from layout\n */\nexport const getBlocks = properties => {\n  var _properties$blocksLay, _properties$blocksLay2;\n  const blocksFieldName = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  return ((_properties$blocksLay = properties[blocksLayoutFieldname]) === null || _properties$blocksLay === void 0 ? void 0 : (_properties$blocksLay2 = _properties$blocksLay.items) === null || _properties$blocksLay2 === void 0 ? void 0 : _properties$blocksLay2.map(n => [n, properties[blocksFieldName][n]])) || [];\n};\n\n/**\n * Move block to different location index within blocks_layout\n * @function moveBlock\n * @param {Object} formData Form data\n * @param {number} source index within form blocks_layout items\n * @param {number} destination index within form blocks_layout items\n * @return {Object} New form data\n */\nexport function moveBlock(formData, source, destination) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  return _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksLayoutFieldname]: {\n      items: move(formData[blocksLayoutFieldname].items, source, destination)\n    }\n  });\n}\n\n/**\n * Delete block by id\n * @function deleteBlock\n * @param {Object} formData Form data\n * @param {string} blockId Block uid\n * @return {Object} New form data\n */\nexport function deleteBlock(formData, blockId) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  let newFormData = _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksLayoutFieldname]: {\n      items: _without(formData[blocksLayoutFieldname].items, blockId)\n    },\n    [blocksFieldname]: _omit(formData[blocksFieldname], [blockId])\n  });\n  if (newFormData[blocksLayoutFieldname].items.length === 0) {\n    newFormData = addBlock(newFormData, config.settings.defaultBlockType, 0);\n  }\n  return newFormData;\n}\n\n/**\n * Add block\n * @function addBlock\n * @param {Object} formData Form data\n * @param {string} type Block type\n * @param {number} index Destination index\n * @return {Array} New block id, New form data\n */\nexport function addBlock(formData, type, index) {\n  const {\n    settings\n  } = config;\n  const id = uuid();\n  const idTrailingBlock = uuid();\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const totalItems = formData[blocksLayoutFieldname].items.length;\n  const insert = index === -1 ? totalItems : index;\n  return [id, _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksLayoutFieldname]: {\n      items: [...formData[blocksLayoutFieldname].items.slice(0, insert), id, ...(type !== settings.defaultBlockType ? [idTrailingBlock] : []), ...formData[blocksLayoutFieldname].items.slice(insert)]\n    },\n    [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n      [id]: {\n        '@type': type\n      }\n    }, type !== settings.defaultBlockType && {\n      [idTrailingBlock]: {\n        '@type': settings.defaultBlockType\n      }\n    }),\n    selected: id\n  })];\n}\n\n/**\n * Mutate block\n * @function mutateBlock\n * @param {Object} formData Form data\n * @param {string} id Block uid to mutate\n * @param {number} value Block's new value\n * @return {Object} New form data\n */\nexport function mutateBlock(formData, id, value) {\n  const {\n    settings\n  } = config;\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const index = formData[blocksLayoutFieldname].items.indexOf(id) + 1;\n\n  // Test if block at index is already a placeholder (trailing) block\n  const trailId = formData[blocksLayoutFieldname].items[index];\n  if (trailId) {\n    const block = formData[blocksFieldname][trailId];\n    if (!blockHasValue(block)) {\n      return _objectSpread(_objectSpread({}, formData), {}, {\n        [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n          [id]: value || null\n        })\n      });\n    }\n  }\n  const idTrailingBlock = uuid();\n  return _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n      [id]: value || null,\n      [idTrailingBlock]: {\n        '@type': settings.defaultBlockType\n      }\n    }),\n    [blocksLayoutFieldname]: {\n      items: [...formData[blocksLayoutFieldname].items.slice(0, index), idTrailingBlock, ...formData[blocksLayoutFieldname].items.slice(index)]\n    }\n  });\n}\n\n/**\n * Insert new block before another block\n * @function insertBlock\n * @param {Object} formData Form data\n * @param {string} id Insert new block before the block with this id\n * @param {number} value New block's value\n * @return {Array} New block id, New form data\n */\nexport function insertBlock(formData, id, value, current = {}, offset = 0) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const index = formData[blocksLayoutFieldname].items.indexOf(id);\n  const newBlockId = uuid();\n  return [newBlockId, _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n      [newBlockId]: value || null,\n      [id]: _objectSpread(_objectSpread({}, formData[blocksFieldname][id]), current)\n    }),\n    [blocksLayoutFieldname]: {\n      items: [...formData[blocksLayoutFieldname].items.slice(0, index + offset), newBlockId, ...formData[blocksLayoutFieldname].items.slice(index + offset)]\n    }\n  })];\n}\n\n/**\n * Change block\n * @function changeBlock\n * @param {Object} formData Form data\n * @param {string} id Block uid to change\n * @param {number} value Block's new value\n * @return {Object} New form data\n */\nexport function changeBlock(formData, id, value) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  return _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n      [id]: value || null\n    })\n  });\n}\n\n/**\n * Get the next block UID within form\n * @function nextBlockId\n * @param {Object} formData Form data\n * @param {string} currentBlock Block uid\n * @return {string} Next block uid\n */\nexport function nextBlockId(formData, currentBlock) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const currentIndex = formData[blocksLayoutFieldname].items.indexOf(currentBlock);\n  if (currentIndex === formData[blocksLayoutFieldname].items.length - 1) {\n    // We are already at the bottom block don't do anything\n    return null;\n  }\n  const newIndex = currentIndex + 1;\n  return formData[blocksLayoutFieldname].items[newIndex];\n}\n\n/**\n * Get the previous block UID within form\n * @function previousBlockId\n * @param {Object} formData Form data\n * @param {string} currentBlock Block uid\n * @return {string} Previous block uid\n */\nexport function previousBlockId(formData, currentBlock) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const currentIndex = formData[blocksLayoutFieldname].items.indexOf(currentBlock);\n  if (currentIndex === 0) {\n    // We are already at the top block don't do anything\n    return null;\n  }\n  const newindex = currentIndex - 1;\n  return formData[blocksLayoutFieldname].items[newindex];\n}\n\n/**\n * Generate empty block form\n * @function emptyBlocksForm\n * @param {Object} formData Form data\n * @return {Object} Empty blocks form with one defaultBlockType block\n */\nexport function emptyBlocksForm() {\n  const {\n    settings\n  } = config;\n  const id = uuid();\n  return {\n    blocks: {\n      [id]: {\n        '@type': settings.defaultBlockType\n      }\n    },\n    blocks_layout: {\n      items: [id]\n    }\n  };\n}\n\n/**\n * Recursively discover blocks in data and call the provided callback\n * @function visitBlocks\n * @param {Object} content A content data structure (an object with blocks and blocks_layout)\n * @param {Function} callback A function to call on each discovered block\n */\nexport function visitBlocks(content, callback) {\n  const queue = getBlocks(content);\n  while (queue.length > 0) {\n    const [id, blockdata] = queue.shift();\n    callback([id, blockdata]);\n\n    // assumes that a block value is like: {blocks, blocks_layout} or\n    // { data: {blocks, blocks_layout}}\n    if (Object.keys(blockdata || {}).indexOf('blocks') > -1) {\n      queue.push(...getBlocks(blockdata));\n    }\n    if (Object.keys((blockdata === null || blockdata === void 0 ? void 0 : blockdata.data) || {}).indexOf('blocks') > -1) {\n      queue.push(...getBlocks(blockdata.data));\n    }\n  }\n}\nlet _logged = false;\n\n/**\n * Initializes data with the default values coming from schema\n */\nexport function applySchemaDefaults({\n  data = {},\n  schema,\n  intl\n}) {\n  if (!intl && !_logged) {\n    // Old code that doesn't pass intl doesn't get ObjectWidget defaults\n    // eslint-disable-next-line no-console\n    console.warn(`You should pass intl to any applySchemaDefaults call. By failing to pass\n      the intl object, your ObjectWidget fields will not get default values\n      extracted from their schema.`);\n    _logged = true;\n  }\n  const derivedData = _merge(Object.keys(schema.properties).reduce((accumulator, currentField) => {\n    return typeof schema.properties[currentField].default !== 'undefined' ? _objectSpread(_objectSpread({}, accumulator), {}, {\n      [currentField]: schema.properties[currentField].default\n    }) : intl && schema.properties[currentField].schema && !(schema.properties[currentField].widget === 'object_list') // TODO: this should be renamed as itemSchema\n    ? _objectSpread(_objectSpread({}, accumulator), {}, {\n      [currentField]: _objectSpread({}, applySchemaDefaults({\n        data: _objectSpread(_objectSpread({}, data[currentField]), accumulator[currentField]),\n        schema: typeof schema.properties[currentField].schema === 'function' ? schema.properties[currentField].schema({\n          data: accumulator[currentField],\n          formData: accumulator[currentField],\n          intl\n        }) : schema.properties[currentField].schema,\n        intl\n      }))\n    }) : accumulator;\n  }, {}), data);\n  return derivedData;\n}\n\n/**\n * Apply the block's default (as defined in schema) to the block data.\n *\n * @function applyBlockDefaults\n * @param {Object} params An object with data, intl and anything else\n * @return {Object} Derived data, with the defaults extracted from the schema\n */\nexport function applyBlockDefaults(_ref, blocksConfig) {\n  let {\n      data,\n      intl\n    } = _ref,\n    rest = _objectWithoutProperties(_ref, _excluded);\n  // We pay attention to not break on a missing (invalid) block.\n  const block_type = data === null || data === void 0 ? void 0 : data['@type'];\n  const {\n    blockSchema\n  } = (blocksConfig || config.blocks.blocksConfig)[block_type] || {};\n  if (!blockSchema) return data;\n  let schema = typeof blockSchema === 'function' ? blockSchema(_objectSpread({\n    data,\n    intl\n  }, rest)) : blockSchema;\n  schema = applySchemaEnhancer({\n    schema,\n    formData: data,\n    intl\n  });\n  return applySchemaDefaults({\n    data,\n    schema,\n    intl\n  });\n}\n\n/**\n * Converts a name+value style pair (ex: color/red) to a classname,\n * such as \"has--color--red\"\n *\n * This can be expanded via the style names, by suffixing them with special\n * converters. See config.settings.styleClassNameConverters. Examples:\n *\n * styleToClassName('theme:noprefix', 'primary') returns \"primary\"\n * styleToClassName('inverted:bool', true) returns 'inverted'\n * styleToClassName('inverted:bool', false) returns ''\n */\nexport const styleToClassName = (key, value, prefix = '') => {\n  const converters = config.settings.styleClassNameConverters;\n  const [name, ...convIds] = key.split(':');\n  return (convIds.length ? convIds : ['default']).map(id => converters[id]).reduce((acc, conv) => conv(acc, value, prefix), name);\n};\nexport const buildStyleClassNamesFromData = (obj = {}, prefix = '') => {\n  // styles has the form:\n  // const styles = {\n  //   color: 'red',\n  //   backgroundColor: '#AABBCC',\n  // }\n  // Returns: ['has--color--red', 'has--backgroundColor--AABBCC']\n\n  return Object.entries(obj).reduce((acc, [k, v]) => [...acc, ...(_isObject(v) ? buildStyleClassNamesFromData(v, `${prefix}${k}--`) : [styleToClassName(k, v, prefix)])], []).filter(v => !!v);\n};\n\n/**\n * Generate classNames from extenders\n *\n * @function buildStyleClassNamesExtenders\n * @param {Object} params An object with data, content and block (current block id)\n * @return {Array} Extender classNames resultant array\n */\nexport const buildStyleClassNamesExtenders = ({\n  block,\n  content,\n  data,\n  classNames\n}) => {\n  return config.settings.styleClassNameExtenders.reduce((acc, extender) => extender({\n    block,\n    content,\n    data,\n    classNames: acc\n  }), classNames);\n};\n\n/**\n * Return previous/next blocks given the content object and the current block id\n *\n * @function getPreviousNextBlock\n * @param {Object} params An object with the content object and block (current block id)\n * @return {Array} An array with the signature [previousBlock, nextBlock]\n */\nexport const getPreviousNextBlock = ({\n  content,\n  block\n}) => {\n  const previousBlock = content['blocks'][content['blocks_layout'].items[content['blocks_layout'].items.indexOf(block) - 1]];\n  const nextBlock = content['blocks'][content['blocks_layout'].items[content['blocks_layout'].items.indexOf(block) + 1]];\n  return [previousBlock, nextBlock];\n};","map":{"version":3,"names":["move","v4","uuid","config","applySchemaEnhancer","getBlocksFieldname","props","key","getBlocksLayoutFieldname","hasBlocksData","undefined","blockHasValue","data","blocks","blockType","check","blocksConfig","getBlocks","properties","blocksFieldName","blocksLayoutFieldname","items","map","n","moveBlock","formData","source","destination","deleteBlock","blockId","blocksFieldname","newFormData","length","addBlock","settings","defaultBlockType","type","index","id","idTrailingBlock","totalItems","insert","slice","selected","mutateBlock","value","indexOf","trailId","block","insertBlock","current","offset","newBlockId","changeBlock","nextBlockId","currentBlock","currentIndex","newIndex","previousBlockId","newindex","emptyBlocksForm","blocks_layout","visitBlocks","content","callback","queue","blockdata","shift","Object","keys","push","_logged","applySchemaDefaults","schema","intl","console","warn","derivedData","reduce","accumulator","currentField","default","widget","applyBlockDefaults","rest","block_type","blockSchema","styleToClassName","prefix","converters","styleClassNameConverters","name","convIds","split","acc","conv","buildStyleClassNamesFromData","obj","entries","k","v","filter","buildStyleClassNamesExtenders","classNames","styleClassNameExtenders","extender","getPreviousNextBlock","previousBlock","nextBlock"],"sources":["/Users/cihanandac/Documents/code-files/utrechtsciencepark/utrecht-science-park/frontend/node_modules/@plone/volto/src/helpers/Blocks/Blocks.js"],"sourcesContent":["/**\n * Blocks helper.\n * @module helpers/Blocks\n */\n\nimport { omit, without, endsWith, find, isObject, keys, merge } from 'lodash';\nimport move from 'lodash-move';\nimport { v4 as uuid } from 'uuid';\nimport config from '@plone/volto/registry';\nimport { applySchemaEnhancer } from '@plone/volto/helpers';\n\n/**\n * Get blocks field.\n * @function getBlocksFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the blocks\n */\nexport function getBlocksFieldname(props) {\n  return (\n    find(\n      keys(props),\n      (key) => key !== 'volto.blocks' && endsWith(key, 'blocks'),\n    ) || null\n  );\n}\n\n/**\n * Get blocks layout field.\n * @function getBlocksLayoutFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the blocks layout\n */\nexport function getBlocksLayoutFieldname(props) {\n  return (\n    find(\n      keys(props),\n      (key) => key !== 'volto.blocks' && endsWith(key, 'blocks_layout'),\n    ) || null\n  );\n}\n\n/**\n * Has blocks data.\n * @function hasBlocksData\n * @param {Object} props Properties.\n * @return {boolean} True if it has blocks data.\n */\nexport function hasBlocksData(props) {\n  return (\n    find(\n      keys(props),\n      (key) => key !== 'volto.blocks' && endsWith(key, 'blocks'),\n    ) !== undefined\n  );\n}\n\n/**\n * Pluggable method to test if a block has a set value (any non-empty value)\n * @function blockHasValue\n * @param {Object} data Block data\n * @return {boolean} True if block has a non-empty value\n */\nexport function blockHasValue(data) {\n  const { blocks } = config;\n  const blockType = data['@type'];\n  const check = blocks.blocksConfig[blockType]?.blockHasValue;\n  if (!check) {\n    return true;\n  }\n  return check(data);\n}\n\n/**\n * Get block pairs of [id, block] from content properties\n * @function getBlocks\n * @param {Object} properties\n * @return {Array} a list of block [id, value] pairs, in order from layout\n */\nexport const getBlocks = (properties) => {\n  const blocksFieldName = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  return (\n    properties[blocksLayoutFieldname]?.items?.map((n) => [\n      n,\n      properties[blocksFieldName][n],\n    ]) || []\n  );\n};\n\n/**\n * Move block to different location index within blocks_layout\n * @function moveBlock\n * @param {Object} formData Form data\n * @param {number} source index within form blocks_layout items\n * @param {number} destination index within form blocks_layout items\n * @return {Object} New form data\n */\nexport function moveBlock(formData, source, destination) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  return {\n    ...formData,\n    [blocksLayoutFieldname]: {\n      items: move(formData[blocksLayoutFieldname].items, source, destination),\n    },\n  };\n}\n\n/**\n * Delete block by id\n * @function deleteBlock\n * @param {Object} formData Form data\n * @param {string} blockId Block uid\n * @return {Object} New form data\n */\nexport function deleteBlock(formData, blockId) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n\n  let newFormData = {\n    ...formData,\n    [blocksLayoutFieldname]: {\n      items: without(formData[blocksLayoutFieldname].items, blockId),\n    },\n    [blocksFieldname]: omit(formData[blocksFieldname], [blockId]),\n  };\n\n  if (newFormData[blocksLayoutFieldname].items.length === 0) {\n    newFormData = addBlock(newFormData, config.settings.defaultBlockType, 0);\n  }\n\n  return newFormData;\n}\n\n/**\n * Add block\n * @function addBlock\n * @param {Object} formData Form data\n * @param {string} type Block type\n * @param {number} index Destination index\n * @return {Array} New block id, New form data\n */\nexport function addBlock(formData, type, index) {\n  const { settings } = config;\n  const id = uuid();\n  const idTrailingBlock = uuid();\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const totalItems = formData[blocksLayoutFieldname].items.length;\n  const insert = index === -1 ? totalItems : index;\n\n  return [\n    id,\n    {\n      ...formData,\n      [blocksLayoutFieldname]: {\n        items: [\n          ...formData[blocksLayoutFieldname].items.slice(0, insert),\n          id,\n          ...(type !== settings.defaultBlockType ? [idTrailingBlock] : []),\n          ...formData[blocksLayoutFieldname].items.slice(insert),\n        ],\n      },\n      [blocksFieldname]: {\n        ...formData[blocksFieldname],\n        [id]: {\n          '@type': type,\n        },\n        ...(type !== settings.defaultBlockType && {\n          [idTrailingBlock]: {\n            '@type': settings.defaultBlockType,\n          },\n        }),\n      },\n      selected: id,\n    },\n  ];\n}\n\n/**\n * Mutate block\n * @function mutateBlock\n * @param {Object} formData Form data\n * @param {string} id Block uid to mutate\n * @param {number} value Block's new value\n * @return {Object} New form data\n */\nexport function mutateBlock(formData, id, value) {\n  const { settings } = config;\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const index = formData[blocksLayoutFieldname].items.indexOf(id) + 1;\n\n  // Test if block at index is already a placeholder (trailing) block\n  const trailId = formData[blocksLayoutFieldname].items[index];\n  if (trailId) {\n    const block = formData[blocksFieldname][trailId];\n    if (!blockHasValue(block)) {\n      return {\n        ...formData,\n        [blocksFieldname]: {\n          ...formData[blocksFieldname],\n          [id]: value || null,\n        },\n      };\n    }\n  }\n\n  const idTrailingBlock = uuid();\n  return {\n    ...formData,\n    [blocksFieldname]: {\n      ...formData[blocksFieldname],\n      [id]: value || null,\n      [idTrailingBlock]: {\n        '@type': settings.defaultBlockType,\n      },\n    },\n    [blocksLayoutFieldname]: {\n      items: [\n        ...formData[blocksLayoutFieldname].items.slice(0, index),\n        idTrailingBlock,\n        ...formData[blocksLayoutFieldname].items.slice(index),\n      ],\n    },\n  };\n}\n\n/**\n * Insert new block before another block\n * @function insertBlock\n * @param {Object} formData Form data\n * @param {string} id Insert new block before the block with this id\n * @param {number} value New block's value\n * @return {Array} New block id, New form data\n */\nexport function insertBlock(formData, id, value, current = {}, offset = 0) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const index = formData[blocksLayoutFieldname].items.indexOf(id);\n\n  const newBlockId = uuid();\n  return [\n    newBlockId,\n    {\n      ...formData,\n      [blocksFieldname]: {\n        ...formData[blocksFieldname],\n        [newBlockId]: value || null,\n        [id]: {\n          ...formData[blocksFieldname][id],\n          ...current,\n        },\n      },\n      [blocksLayoutFieldname]: {\n        items: [\n          ...formData[blocksLayoutFieldname].items.slice(0, index + offset),\n          newBlockId,\n          ...formData[blocksLayoutFieldname].items.slice(index + offset),\n        ],\n      },\n    },\n  ];\n}\n\n/**\n * Change block\n * @function changeBlock\n * @param {Object} formData Form data\n * @param {string} id Block uid to change\n * @param {number} value Block's new value\n * @return {Object} New form data\n */\nexport function changeBlock(formData, id, value) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  return {\n    ...formData,\n    [blocksFieldname]: {\n      ...formData[blocksFieldname],\n      [id]: value || null,\n    },\n  };\n}\n\n/**\n * Get the next block UID within form\n * @function nextBlockId\n * @param {Object} formData Form data\n * @param {string} currentBlock Block uid\n * @return {string} Next block uid\n */\nexport function nextBlockId(formData, currentBlock) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const currentIndex = formData[blocksLayoutFieldname].items.indexOf(\n    currentBlock,\n  );\n\n  if (currentIndex === formData[blocksLayoutFieldname].items.length - 1) {\n    // We are already at the bottom block don't do anything\n    return null;\n  }\n\n  const newIndex = currentIndex + 1;\n  return formData[blocksLayoutFieldname].items[newIndex];\n}\n\n/**\n * Get the previous block UID within form\n * @function previousBlockId\n * @param {Object} formData Form data\n * @param {string} currentBlock Block uid\n * @return {string} Previous block uid\n */\nexport function previousBlockId(formData, currentBlock) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const currentIndex = formData[blocksLayoutFieldname].items.indexOf(\n    currentBlock,\n  );\n\n  if (currentIndex === 0) {\n    // We are already at the top block don't do anything\n    return null;\n  }\n  const newindex = currentIndex - 1;\n  return formData[blocksLayoutFieldname].items[newindex];\n}\n\n/**\n * Generate empty block form\n * @function emptyBlocksForm\n * @param {Object} formData Form data\n * @return {Object} Empty blocks form with one defaultBlockType block\n */\nexport function emptyBlocksForm() {\n  const { settings } = config;\n  const id = uuid();\n  return {\n    blocks: {\n      [id]: {\n        '@type': settings.defaultBlockType,\n      },\n    },\n    blocks_layout: { items: [id] },\n  };\n}\n\n/**\n * Recursively discover blocks in data and call the provided callback\n * @function visitBlocks\n * @param {Object} content A content data structure (an object with blocks and blocks_layout)\n * @param {Function} callback A function to call on each discovered block\n */\nexport function visitBlocks(content, callback) {\n  const queue = getBlocks(content);\n  while (queue.length > 0) {\n    const [id, blockdata] = queue.shift();\n    callback([id, blockdata]);\n\n    // assumes that a block value is like: {blocks, blocks_layout} or\n    // { data: {blocks, blocks_layout}}\n    if (Object.keys(blockdata || {}).indexOf('blocks') > -1) {\n      queue.push(...getBlocks(blockdata));\n    }\n    if (Object.keys(blockdata?.data || {}).indexOf('blocks') > -1) {\n      queue.push(...getBlocks(blockdata.data));\n    }\n  }\n}\n\nlet _logged = false;\n\n/**\n * Initializes data with the default values coming from schema\n */\nexport function applySchemaDefaults({ data = {}, schema, intl }) {\n  if (!intl && !_logged) {\n    // Old code that doesn't pass intl doesn't get ObjectWidget defaults\n    // eslint-disable-next-line no-console\n    console.warn(\n      `You should pass intl to any applySchemaDefaults call. By failing to pass\n      the intl object, your ObjectWidget fields will not get default values\n      extracted from their schema.`,\n    );\n    _logged = true;\n  }\n\n  const derivedData = merge(\n    Object.keys(schema.properties).reduce((accumulator, currentField) => {\n      return typeof schema.properties[currentField].default !== 'undefined'\n        ? {\n            ...accumulator,\n            [currentField]: schema.properties[currentField].default,\n          }\n        : intl &&\n          schema.properties[currentField].schema &&\n          !(schema.properties[currentField].widget === 'object_list') // TODO: this should be renamed as itemSchema\n        ? {\n            ...accumulator,\n            [currentField]: {\n              ...applySchemaDefaults({\n                data: { ...data[currentField], ...accumulator[currentField] },\n                schema:\n                  typeof schema.properties[currentField].schema === 'function'\n                    ? schema.properties[currentField].schema({\n                        data: accumulator[currentField],\n                        formData: accumulator[currentField],\n                        intl,\n                      })\n                    : schema.properties[currentField].schema,\n                intl,\n              }),\n            },\n          }\n        : accumulator;\n    }, {}),\n    data,\n  );\n\n  return derivedData;\n}\n\n/**\n * Apply the block's default (as defined in schema) to the block data.\n *\n * @function applyBlockDefaults\n * @param {Object} params An object with data, intl and anything else\n * @return {Object} Derived data, with the defaults extracted from the schema\n */\nexport function applyBlockDefaults({ data, intl, ...rest }, blocksConfig) {\n  // We pay attention to not break on a missing (invalid) block.\n  const block_type = data?.['@type'];\n  const { blockSchema } =\n    (blocksConfig || config.blocks.blocksConfig)[block_type] || {};\n  if (!blockSchema) return data;\n\n  let schema =\n    typeof blockSchema === 'function'\n      ? blockSchema({ data, intl, ...rest })\n      : blockSchema;\n  schema = applySchemaEnhancer({ schema, formData: data, intl });\n\n  return applySchemaDefaults({ data, schema, intl });\n}\n\n/**\n * Converts a name+value style pair (ex: color/red) to a classname,\n * such as \"has--color--red\"\n *\n * This can be expanded via the style names, by suffixing them with special\n * converters. See config.settings.styleClassNameConverters. Examples:\n *\n * styleToClassName('theme:noprefix', 'primary') returns \"primary\"\n * styleToClassName('inverted:bool', true) returns 'inverted'\n * styleToClassName('inverted:bool', false) returns ''\n */\nexport const styleToClassName = (key, value, prefix = '') => {\n  const converters = config.settings.styleClassNameConverters;\n  const [name, ...convIds] = key.split(':');\n\n  return (convIds.length ? convIds : ['default'])\n    .map((id) => converters[id])\n    .reduce((acc, conv) => conv(acc, value, prefix), name);\n};\n\nexport const buildStyleClassNamesFromData = (obj = {}, prefix = '') => {\n  // styles has the form:\n  // const styles = {\n  //   color: 'red',\n  //   backgroundColor: '#AABBCC',\n  // }\n  // Returns: ['has--color--red', 'has--backgroundColor--AABBCC']\n\n  return Object.entries(obj)\n    .reduce(\n      (acc, [k, v]) => [\n        ...acc,\n        ...(isObject(v)\n          ? buildStyleClassNamesFromData(v, `${prefix}${k}--`)\n          : [styleToClassName(k, v, prefix)]),\n      ],\n      [],\n    )\n    .filter((v) => !!v);\n};\n\n/**\n * Generate classNames from extenders\n *\n * @function buildStyleClassNamesExtenders\n * @param {Object} params An object with data, content and block (current block id)\n * @return {Array} Extender classNames resultant array\n */\nexport const buildStyleClassNamesExtenders = ({\n  block,\n  content,\n  data,\n  classNames,\n}) => {\n  return config.settings.styleClassNameExtenders.reduce(\n    (acc, extender) => extender({ block, content, data, classNames: acc }),\n    classNames,\n  );\n};\n\n/**\n * Return previous/next blocks given the content object and the current block id\n *\n * @function getPreviousNextBlock\n * @param {Object} params An object with the content object and block (current block id)\n * @return {Array} An array with the signature [previousBlock, nextBlock]\n */\nexport const getPreviousNextBlock = ({ content, block }) => {\n  const previousBlock =\n    content['blocks'][\n      content['blocks_layout'].items[\n        content['blocks_layout'].items.indexOf(block) - 1\n      ]\n    ];\n  const nextBlock =\n    content['blocks'][\n      content['blocks_layout'].items[\n        content['blocks_layout'].items.indexOf(block) + 1\n      ]\n    ];\n\n  return [previousBlock, nextBlock];\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}